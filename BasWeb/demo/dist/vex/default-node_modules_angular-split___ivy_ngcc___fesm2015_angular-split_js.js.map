{"version":3,"file":"default-node_modules_angular-split___ivy_ngcc___fesm2015_angular-split_js.js","mappings":";;;;;;;;;;;;;;;;;;;;AAAwM;AACzJ;AACJ;AACG;;AAE9C;AACA;AACA;AACA,cAAc,wHAAwH;AACtI;AACA;AACA,WAAW,GAAG;AACd,YAAY;AACZ;AACwC;AACE;;AAE1C;AACA,gEAAgE;AAChE,gBAAgB,8DAAuB;AACvC,IAAI,4DAAqB;AACzB,IAAI,wDAAiB,sGAAsG,2DAAoB,OAAO,iBAAiB,2DAAoB,UAAU,eAAe,2DAAoB,IAAI,sEAAsE,yGAAyG,2DAAoB,OAAO,iBAAiB,2DAAoB,UAAU,eAAe,2DAAoB,IAAI,sEAAsE,mGAAmG,2DAAoB,OAAO,iBAAiB,2DAAoB,UAAU,gBAAgB,2DAAoB,IAAI,mDAAmD,qGAAqG,2DAAoB,OAAO,iBAAiB,2DAAoB,UAAU,gBAAgB,2DAAoB,IAAI,mDAAmD;AACpmC,IAAI,uDAAgB;AACpB,IAAI,0DAAmB;AACvB,EAAE;AACF,qBAAqB,2DAAoB;AACzC,mBAAmB,2DAAoB;AACvC,IAAI,yDAAkB;AACtB;AACA,0DAA0D;AAC1D,IAAI,wDAAiB;AACrB,EAAE;AACF;AACA,IAAI,wDAAiB;AACrB;AACA;AACA;AACA;AACA,qBAAqB,GAAG,0DAA0D,GAAG;AACrF;AACA,4BAA4B,GAAG;AAC/B,4BAA4B,GAAG;AAC/B;AACA;AACA;AACA,0BAA0B,GAAG,mDAAmD,GAAG;AACnF;AACA,4BAA4B,GAAG;AAC/B,4BAA4B,GAAG;AAC/B;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,WAAW,GAAG;AACd,YAAY;AACZ;AACA;AACA,eAAe,GAAG;AAClB,8BAA8B,GAAG;AACjC;AACA;AACA;AACA,WAAW,GAAG;AACd,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,WAAW,GAAG;AACd,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,WAAW,GAAG;AACd,YAAY;AACZ;AACA;AACA;AACA;AACA,mBAAmB,GAAG;AACtB;AACA,mBAAmB,GAAG;AACtB,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA;AACA;AACA,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,WAAW,GAAG;AACd,WAAW,GAAG;AACd,WAAW,GAAG;AACd,YAAY;AACZ;AACA;AACA;AACA,eAAe,GAAG;AAClB,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA,mBAAmB,GAAG;AACtB;AACA;AACA;AACA;AACA,KAAK,KAAK,0BAA0B;AACpC;AACA;AACA,WAAW,GAAG;AACd,WAAW,GAAG;AACd,WAAW,GAAG;AACd,WAAW,GAAG;AACd,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,WAAW,GAAG;AACd,WAAW,GAAG;AACd,YAAY;AACZ;AACA;AACA,eAAe,GAAG;AAClB;AACA,eAAe,GAAG;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,GAAG;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,GAAG;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,WAAW,GAAG;AACd,WAAW,GAAG;AACd,YAAY;AACZ;AACA;AACA,eAAe,GAAG;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,WAAW,GAAG;AACd,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,wHAAwH;AACtI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,WAAW,MAAM,qCAAqC;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,GAAG;AAClB,eAAe,GAAG;AAClB,eAAe,GAAG;AAClB,eAAe,GAAG;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,uDAAY;AACzC,2BAA2B,uDAAY;AACvC,+BAA+B,uDAAY;AAC3C,kCAAkC,uDAAY;AAC9C,uCAAuC,yCAAO;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA;AACA,+DAA+D,gBAAgB;AAC/E,kEAAkE,2DAA2D;AAC7H;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA;AACA,+DAA+D,WAAW;AAC1E,kEAAkE,6CAA6C;AAC/G;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,mBAAmB,4CAAU;AAC7B,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA,2EAA2E,4DAAY;AACvF;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA,mBAAmB,GAAG;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA;AACA,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA;AACA,uBAAuB,GAAG;AAC1B;AACA,uBAAuB,GAAG;AAC1B,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA;AACA,uBAAuB,GAAG;AAC1B;AACA,uBAAuB,GAAG;AAC1B,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,GAAG;AAClB,eAAe,GAAG;AAClB,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA,mBAAmB,GAAG;AACtB;AACA,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,mBAAmB,GAAG;AACtB;AACA;AACA;AACA;AACA;AACA,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA,mBAAmB,GAAG;AACtB;AACA,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,mBAAmB,GAAG;AACtB;AACA;AACA,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA;AACA;AACA;AACA,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,mBAAmB,GAAG;AACtB;AACA,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA;AACA,mBAAmB,GAAG;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,GAAG;AACtB,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,GAAG;AAClB,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,GAAG;AAC1B,wBAAwB;AACxB;AACA;AACA;AACA,2BAA2B,GAAG;AAC9B,2BAA2B,GAAG;AAC9B,4BAA4B;AAC5B;AACA,sCAAsC,GAAG,sCAAsC,GAAG;AAClF;AACA;AACA;AACA,uBAAuB,GAAG;AAC1B,uBAAuB,GAAG;AAC1B,wBAAwB;AACxB;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,uBAAuB,GAAG;AAC1B;AACA,uBAAuB,GAAG;AAC1B,wBAAwB;AACxB;AACA;AACA;AACA;AACA,+BAA+B,GAAG;AAClC;AACA;AACA,+BAA+B,GAAG;AAClC,gCAAgC;AAChC;AACA;AACA,+DAA+D,GAAG;AAClE;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,mCAAmC,GAAG;AACtC,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,mCAAmC,GAAG;AACtC;AACA,mCAAmC,GAAG;AACtC,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,GAAG;AAC1C,uCAAuC,GAAG;AAC1C,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA,uCAAuC,GAAG;AAC1C;AACA;AACA,uCAAuC,GAAG;AAC1C,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,GAAG;AAC9B;AACA;AACA,2BAA2B,GAAG;AAC9B,4BAA4B;AAC5B;AACA;AACA,+DAA+D,UAAU,MAAM,aAAa,GAAG,uCAAuC;AACtI,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,GAAG;AAC1B,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,UAAU;AACvE;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,eAAe,GAAG;AAClB,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA,mBAAmB,GAAG;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,eAAe,GAAG;AAClB,eAAe,GAAG;AAClB,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA;AACA,uBAAuB,GAAG;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,mBAAmB,GAAG;AACtB,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,GAAG;AACtB;AACA;AACA;AACA;AACA,mBAAmB,GAAG;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,GAAG;AACtB;AACA,mBAAmB,GAAG;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,GAAG;AAC1B;AACA,uBAAuB,GAAG;AAC1B;AACA,uBAAuB,GAAG;AAC1B,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,GAAG;AACtC,oCAAoC;AACpC;AACA;AACA,mCAAmC,GAAG;AACtC,mCAAmC,GAAG;AACtC,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA;AACA;AACA,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,IAAI;AACnB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA;AACA;AACA,uBAAuB,GAAG;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA,eAAe,GAAG;AAClB,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA,mBAAmB,GAAG;AACtB;AACA;AACA,kCAAkC,kBAAkB;AACpD;AACA;AACA,gCAAgC,kBAAkB;AAClD;AACA;AACA,oCAAoC,kBAAkB;AACtD;AACA;AACA,uCAAuC,kBAAkB;AACzD;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,kBAAkB;AAC9D;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,eAAe,GAAG;AAClB,eAAe,GAAG;AAClB,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA,mBAAmB,GAAG;AACtB;AACA,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,mBAAmB,GAAG;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,GAAG;AACtB;AACA,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA,kDAAkD,yBAAyB;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA,mBAAmB,GAAG;AACtB;AACA,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,GAAG;AACtB;AACA,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA,kDAAkD,uCAAuC;AACzF;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,iCAAiC,+DAAwB,CAAC,iDAAa,GAAG,+DAAwB,CAAC,qDAAiB,GAAG,+DAAwB,CAAC,4DAAwB,GAAG,+DAAwB,CAAC,oDAAgB;AAC/Q,oCAAoC,+DAAwB,GAAG,qGAAqG;AACpK,QAAQ,yDAAkB;AAC1B,MAAM;AACN;AACA,QAAQ,4DAAqB,MAAM,yDAAkB;AACrD,OAAO,YAAY,4OAA4O,aAAa,0IAA0I,oZAAoZ;AAC1yB,QAAQ,6DAAsB;AAC9B,QAAQ,0DAAmB;AAC3B,QAAQ,wDAAiB;AACzB,MAAM;AACN,QAAQ,uDAAgB;AACxB,QAAQ,wDAAiB;AACzB,OAAO,eAAe,oDAAc,EAAE,iDAAW,8BAA8B,oBAAoB,aAAa,iBAAiB,YAAY,2BAA2B,gBAAgB,WAAW,uDAAuD,mBAAmB,sBAAsB,aAAa,YAAY,cAAc,uBAAuB,iFAAiF,yBAAyB,oBAAoB,kGAAkG,wBAAwB,4BAA4B,YAAY,WAAW,oCAAoC,YAAY,cAAc,kBAAkB,gBAAgB,8CAA8C,uBAAuB,kBAAkB,kBAAkB,+BAA+B,mBAAmB,qEAAqE,kBAAkB,mBAAmB,YAAY,gHAAgH,sCAAsC,uIAAuI,kDAAkD,YAAY,6BAA6B,sBAAsB,mEAAmE,kBAAkB,sBAAsB,WAAW,8GAA8G,sCAAsC,2JAA2J,gDAAgD,WAAW,0DAA0D,YAAY,mEAAmE,eAAe,8GAA8G,uBAAuB,4KAA4K,0BAA0B,wBAAwB;AACt2E;AACA;AACA,MAAM,MAAM,iDAAM,EAAE;AACpB,MAAM,MAAM,qDAAU,EAAE;AACxB,MAAM,MAAM,4DAAiB,EAAE;AAC/B,MAAM,MAAM,oDAAS;AACrB;AACA;AACA,kBAAkB,MAAM,gDAAK,EAAE;AAC/B,aAAa,MAAM,gDAAK,EAAE;AAC1B,mBAAmB,MAAM,gDAAK,EAAE;AAChC,mBAAmB,MAAM,gDAAK,EAAE;AAChC,qBAAqB,MAAM,gDAAK,EAAE;AAClC,sBAAsB,MAAM,gDAAK,EAAE;AACnC,iBAAiB,MAAM,gDAAK,EAAE;AAC9B,YAAY,MAAM,gDAAK,EAAE;AACzB,+BAA+B,MAAM,gDAAK,EAAE;AAC5C,sBAAsB,MAAM,iDAAM,EAAE;AACpC,kBAAkB,MAAM,iDAAM,EAAE;AAChC,gBAAgB,MAAM,iDAAM,EAAE;AAC9B,oBAAoB,MAAM,iDAAM,EAAE;AAClC,uBAAuB,MAAM,iDAAM,EAAE;AACrC,kBAAkB,MAAM,uDAAY,wBAAwB;AAC5D;AACA,eAAe,mDAAmD,+DAAwB;AAC1F,cAAc,oDAAS;AACvB;AACA;AACA;AACA,iCAAiC,yEAA8B;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,qEAA0B;AACzD,gCAAgC,oBAAoB,aAAa,iBAAiB,YAAY,2BAA2B,gBAAgB,WAAW,uBAAuB,mBAAmB,sBAAsB,aAAa,YAAY,cAAc,uBAAuB,iDAAiD,yBAAyB,oBAAoB,6CAA6C,wBAAwB,4BAA4B,YAAY,WAAW,+BAA+B,YAAY,cAAc,kBAAkB,gBAAgB,yCAAyC,uBAAuB,kBAAkB,kBAAkB,oBAAoB,mBAAmB,qCAAqC,kBAAkB,mBAAmB,YAAY,2DAA2D,sCAAsC,uIAAuI,6CAA6C,YAAY,kBAAkB,sBAAsB,mCAAmC,kBAAkB,sBAAsB,WAAW,yDAAyD,sCAAsC,2JAA2J,2CAA2C,WAAW,qDAAqD,YAAY,mCAAmC,eAAe,yDAAyD,uBAAuB,sIAAsI,0BAA0B;AACt1D,aAAa;AACb,KAAK,iBAAiB,UAAU,MAAM,iDAAa,EAAE,IAAI,MAAM,qDAAiB,EAAE,IAAI,MAAM,4DAAwB,EAAE,IAAI,MAAM,oDAAgB,EAAE,IAAI,IAAI;AAC1J,kBAAkB,iDAAM;AACxB,SAAS;AACT,kBAAkB,iDAAM;AACxB,SAAS;AACT,kBAAkB,iDAAM;AACxB,SAAS;AACT,kBAAkB,iDAAM;AACxB,SAAS;AACT,kBAAkB,gDAAK;AACvB,SAAS;AACT,kBAAkB,gDAAK;AACvB,SAAS;AACT,kBAAkB,gDAAK;AACvB,SAAS;AACT,kBAAkB,gDAAK;AACvB,SAAS;AACT,kBAAkB,gDAAK;AACvB,SAAS;AACT,kBAAkB,gDAAK;AACvB,SAAS;AACT,kBAAkB,gDAAK;AACvB,SAAS;AACT,kBAAkB,gDAAK;AACvB,SAAS;AACT,kBAAkB,gDAAK;AACvB,SAAS;AACT,kBAAkB,iDAAM;AACxB,SAAS;AACT,kBAAkB,uDAAY;AAC9B;AACA,SAAS,GAAG,IAAI;AAChB,IAAI,KAAK,EAAE,EAuIV;;AAED;AACA;AACA;AACA,cAAc,wHAAwH;AACtI;AACA;AACA;AACA,eAAe,GAAG;AAClB,eAAe,GAAG;AAClB,eAAe,GAAG;AAClB,eAAe,GAAG;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,uBAAuB,GAAG;AAC1B,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,eAAe,GAAG;AAClB,eAAe,GAAG;AAClB,eAAe,GAAG;AAClB,eAAe,GAAG;AAClB,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA,SAAS;AACT;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,uBAAuB,GAAG;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,IAAI;AACnB,eAAe,IAAI;AACnB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,mEAAmE,qCAAqC,+DAAwB,CAAC,iDAAa,GAAG,+DAAwB,CAAC,qDAAiB,GAAG,+DAAwB,CAAC,oDAAgB,GAAG,+DAAwB;AAClQ,wCAAwC,+DAAwB,GAAG,+FAA+F,gHAAgH,6BAA6B;AAC/S;AACA;AACA,MAAM,MAAM,iDAAM,EAAE;AACpB,MAAM,MAAM,qDAAU,EAAE;AACxB,MAAM,MAAM,oDAAS,EAAE;AACvB,MAAM;AACN;AACA;AACA,cAAc,MAAM,gDAAK,EAAE;AAC3B,aAAa,MAAM,gDAAK,EAAE;AAC1B,gBAAgB,MAAM,gDAAK,EAAE;AAC7B,gBAAgB,MAAM,gDAAK,EAAE;AAC7B,iBAAiB,MAAM,gDAAK,EAAE;AAC9B,gBAAgB,MAAM,gDAAK,EAAE;AAC7B;AACA,eAAe,mDAAmD,+DAAwB;AAC1F,cAAc,oDAAS;AACvB;AACA;AACA;AACA,aAAa;AACb,KAAK,iBAAiB,UAAU,MAAM,iDAAa,EAAE,IAAI,MAAM,qDAAiB,EAAE,IAAI,MAAM,oDAAgB,EAAE,IAAI,sBAAsB,IAAI,IAAI;AAChJ,kBAAkB,gDAAK;AACvB,SAAS;AACT,kBAAkB,gDAAK;AACvB,SAAS;AACT,kBAAkB,gDAAK;AACvB,SAAS;AACT,kBAAkB,gDAAK;AACvB,SAAS;AACT,kBAAkB,gDAAK;AACvB,SAAS;AACT,kBAAkB,gDAAK;AACvB,SAAS,GAAG,IAAI;AAChB,IAAI,KAAK,EAAE,EA0DV;;AAED;AACA;AACA;AACA,cAAc,wHAAwH;AACtI;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE;AACnE,wCAAwC,8DAAuB,GAAG,0BAA0B;AAC5F,wCAAwC,8DAAuB,GAAG,WAAW,yDAAY,IAAI;AAC7F,eAAe,mDAAmD,+DAAwB;AAC1F,cAAc,mDAAQ;AACtB;AACA,0BAA0B,yDAAY;AACtC;AACA;AACA,aAAa;AACb,KAAK,iBAAiB;AACtB,eAAe,mDAAmD,gEAAyB,uBAAuB,4BAA4B,8CAA8C,yBAAyB,QAAQ,yDAAY,IAAI,yBAAyB,gDAAgD,IAAI;;AAE1T;AACA;AACA;AACA,cAAc,wHAAwH;AACtI;;AAEA;AACA;AACA;AACA,cAAc,wHAAwH;AACtI;;AAEkE","sources":["./node_modules/angular-split/__ivy_ngcc__/fesm2015/angular-split.js"],"sourcesContent":["import { EventEmitter, Component, ChangeDetectionStrategy, ViewEncapsulation, NgZone, ElementRef, ChangeDetectorRef, Renderer2, Input, Output, ViewChildren, Directive, NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { Subject, Observable } from 'rxjs';\nimport { debounceTime } from 'rxjs/operators';\n\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/utils.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} event\n * @return {?}\n */\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@angular/common';\n\nconst _c0 = [\"gutterEls\"];\nfunction SplitComponent_ng_template_1_div_0_Template(rf, ctx) { if (rf & 1) {\n    const _r7 = ɵngcc0.ɵɵgetCurrentView();\n    ɵngcc0.ɵɵelementStart(0, \"div\", 2, 3);\n    ɵngcc0.ɵɵlistener(\"mousedown\", function SplitComponent_ng_template_1_div_0_Template_div_mousedown_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r7); const index_r1 = ɵngcc0.ɵɵnextContext().index; const ctx_r5 = ɵngcc0.ɵɵnextContext(); return ctx_r5.startDragging($event, index_r1 * 2 + 1, index_r1 + 1); })(\"touchstart\", function SplitComponent_ng_template_1_div_0_Template_div_touchstart_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r7); const index_r1 = ɵngcc0.ɵɵnextContext().index; const ctx_r8 = ɵngcc0.ɵɵnextContext(); return ctx_r8.startDragging($event, index_r1 * 2 + 1, index_r1 + 1); })(\"mouseup\", function SplitComponent_ng_template_1_div_0_Template_div_mouseup_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r7); const index_r1 = ɵngcc0.ɵɵnextContext().index; const ctx_r10 = ɵngcc0.ɵɵnextContext(); return ctx_r10.clickGutter($event, index_r1 + 1); })(\"touchend\", function SplitComponent_ng_template_1_div_0_Template_div_touchend_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r7); const index_r1 = ɵngcc0.ɵɵnextContext().index; const ctx_r12 = ɵngcc0.ɵɵnextContext(); return ctx_r12.clickGutter($event, index_r1 + 1); });\n    ɵngcc0.ɵɵelement(2, \"div\", 4);\n    ɵngcc0.ɵɵelementEnd();\n} if (rf & 2) {\n    const index_r1 = ɵngcc0.ɵɵnextContext().index;\n    const ctx_r3 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵstyleProp(\"flex-basis\", ctx_r3.gutterSize, \"px\")(\"order\", index_r1 * 2 + 1);\n} }\nfunction SplitComponent_ng_template_1_Template(rf, ctx) { if (rf & 1) {\n    ɵngcc0.ɵɵtemplate(0, SplitComponent_ng_template_1_div_0_Template, 3, 4, \"div\", 1);\n} if (rf & 2) {\n    const last_r2 = ctx.last;\n    ɵngcc0.ɵɵproperty(\"ngIf\", last_r2 === false);\n} }\nconst _c1 = [\"*\"];\nfunction getPointFromEvent(event) {\n    // TouchEvent\n    if (((/** @type {?} */ (event))).changedTouches !== undefined && ((/** @type {?} */ (event))).changedTouches.length > 0) {\n        return {\n            x: ((/** @type {?} */ (event))).changedTouches[0].clientX,\n            y: ((/** @type {?} */ (event))).changedTouches[0].clientY,\n        };\n    }\n    // MouseEvent\n    else if (((/** @type {?} */ (event))).clientX !== undefined && ((/** @type {?} */ (event))).clientY !== undefined) {\n        return {\n            x: ((/** @type {?} */ (event))).clientX,\n            y: ((/** @type {?} */ (event))).clientY,\n        };\n    }\n    return null;\n}\n/**\n * @param {?} elRef\n * @param {?} direction\n * @return {?}\n */\nfunction getElementPixelSize(elRef, direction) {\n    /** @type {?} */\n    const rect = ((/** @type {?} */ (elRef.nativeElement))).getBoundingClientRect();\n    return direction === 'horizontal' ? rect.width : rect.height;\n}\n/**\n * @param {?} v\n * @return {?}\n */\nfunction getInputBoolean(v) {\n    return typeof v === 'boolean' ? v : v === 'false' ? false : true;\n}\n/**\n * @template T\n * @param {?} v\n * @param {?} defaultValue\n * @return {?}\n */\nfunction getInputPositiveNumber(v, defaultValue) {\n    if (v === null || v === undefined)\n        return defaultValue;\n    v = Number(v);\n    return !isNaN(v) && v >= 0 ? v : defaultValue;\n}\n/**\n * @param {?} unit\n * @param {?} sizes\n * @return {?}\n */\nfunction isUserSizesValid(unit, sizes) {\n    // All sizes have to be not null and total should be 100\n    if (unit === 'percent') {\n        /** @type {?} */\n        const total = sizes.reduce((/**\n         * @param {?} total\n         * @param {?} s\n         * @return {?}\n         */\n        (total, s) => (s !== null ? total + s : total)), 0);\n        return sizes.every((/**\n         * @param {?} s\n         * @return {?}\n         */\n        (s) => s !== null)) && total > 99.9 && total < 100.1;\n    }\n    // A size at null is mandatory but only one.\n    if (unit === 'pixel') {\n        return sizes.filter((/**\n         * @param {?} s\n         * @return {?}\n         */\n        (s) => s === null)).length === 1;\n    }\n}\n/**\n * @param {?} a\n * @return {?}\n */\nfunction getAreaMinSize(a) {\n    if (a.size === null) {\n        return null;\n    }\n    if (a.component.lockSize === true) {\n        return a.size;\n    }\n    if (a.component.minSize === null) {\n        return null;\n    }\n    if (a.component.minSize > a.size) {\n        return a.size;\n    }\n    return a.component.minSize;\n}\n/**\n * @param {?} a\n * @return {?}\n */\nfunction getAreaMaxSize(a) {\n    if (a.size === null) {\n        return null;\n    }\n    if (a.component.lockSize === true) {\n        return a.size;\n    }\n    if (a.component.maxSize === null) {\n        return null;\n    }\n    if (a.component.maxSize < a.size) {\n        return a.size;\n    }\n    return a.component.maxSize;\n}\n/**\n * @param {?} unit\n * @param {?} sideAreas\n * @param {?} pixels\n * @param {?} allAreasSizePixel\n * @return {?}\n */\nfunction getGutterSideAbsorptionCapacity(unit, sideAreas, pixels, allAreasSizePixel) {\n    return sideAreas.reduce((/**\n     * @param {?} acc\n     * @param {?} area\n     * @return {?}\n     */\n    (acc, area) => {\n        /** @type {?} */\n        const res = getAreaAbsorptionCapacity(unit, area, acc.remain, allAreasSizePixel);\n        acc.list.push(res);\n        acc.remain = res.pixelRemain;\n        return acc;\n    }), { remain: pixels, list: [] });\n}\n/**\n * @param {?} unit\n * @param {?} areaSnapshot\n * @param {?} pixels\n * @param {?} allAreasSizePixel\n * @return {?}\n */\nfunction getAreaAbsorptionCapacity(unit, areaSnapshot, pixels, allAreasSizePixel) {\n    // No pain no gain\n    if (pixels === 0) {\n        return {\n            areaSnapshot,\n            pixelAbsorb: 0,\n            percentAfterAbsorption: areaSnapshot.sizePercentAtStart,\n            pixelRemain: 0,\n        };\n    }\n    // Area start at zero and need to be reduced, not possible\n    if (areaSnapshot.sizePixelAtStart === 0 && pixels < 0) {\n        return {\n            areaSnapshot,\n            pixelAbsorb: 0,\n            percentAfterAbsorption: 0,\n            pixelRemain: pixels,\n        };\n    }\n    if (unit === 'percent') {\n        return getAreaAbsorptionCapacityPercent(areaSnapshot, pixels, allAreasSizePixel);\n    }\n    if (unit === 'pixel') {\n        return getAreaAbsorptionCapacityPixel(areaSnapshot, pixels, allAreasSizePixel);\n    }\n}\n/**\n * @param {?} areaSnapshot\n * @param {?} pixels\n * @param {?} allAreasSizePixel\n * @return {?}\n */\nfunction getAreaAbsorptionCapacityPercent(areaSnapshot, pixels, allAreasSizePixel) {\n    /** @type {?} */\n    const tempPixelSize = areaSnapshot.sizePixelAtStart + pixels;\n    /** @type {?} */\n    const tempPercentSize = (tempPixelSize / allAreasSizePixel) * 100\n    // ENLARGE AREA\n    ;\n    // ENLARGE AREA\n    if (pixels > 0) {\n        // If maxSize & newSize bigger than it > absorb to max and return remaining pixels\n        if (areaSnapshot.area.maxSize !== null && tempPercentSize > areaSnapshot.area.maxSize) {\n            // Use area.area.maxSize as newPercentSize and return calculate pixels remaining\n            /** @type {?} */\n            const maxSizePixel = (areaSnapshot.area.maxSize / 100) * allAreasSizePixel;\n            return {\n                areaSnapshot,\n                pixelAbsorb: maxSizePixel,\n                percentAfterAbsorption: areaSnapshot.area.maxSize,\n                pixelRemain: areaSnapshot.sizePixelAtStart + pixels - maxSizePixel,\n            };\n        }\n        return {\n            areaSnapshot,\n            pixelAbsorb: pixels,\n            percentAfterAbsorption: tempPercentSize > 100 ? 100 : tempPercentSize,\n            pixelRemain: 0,\n        };\n    }\n    // REDUCE AREA\n    else if (pixels < 0) {\n        // If minSize & newSize smaller than it > absorb to min and return remaining pixels\n        if (areaSnapshot.area.minSize !== null && tempPercentSize < areaSnapshot.area.minSize) {\n            // Use area.area.minSize as newPercentSize and return calculate pixels remaining\n            /** @type {?} */\n            const minSizePixel = (areaSnapshot.area.minSize / 100) * allAreasSizePixel;\n            return {\n                areaSnapshot,\n                pixelAbsorb: minSizePixel,\n                percentAfterAbsorption: areaSnapshot.area.minSize,\n                pixelRemain: areaSnapshot.sizePixelAtStart + pixels - minSizePixel,\n            };\n        }\n        // If reduced under zero > return remaining pixels\n        else if (tempPercentSize < 0) {\n            // Use 0 as newPercentSize and return calculate pixels remaining\n            return {\n                areaSnapshot,\n                pixelAbsorb: -areaSnapshot.sizePixelAtStart,\n                percentAfterAbsorption: 0,\n                pixelRemain: pixels + areaSnapshot.sizePixelAtStart,\n            };\n        }\n        return {\n            areaSnapshot,\n            pixelAbsorb: pixels,\n            percentAfterAbsorption: tempPercentSize,\n            pixelRemain: 0,\n        };\n    }\n}\n/**\n * @param {?} areaSnapshot\n * @param {?} pixels\n * @param {?} containerSizePixel\n * @return {?}\n */\nfunction getAreaAbsorptionCapacityPixel(areaSnapshot, pixels, containerSizePixel) {\n    /** @type {?} */\n    const tempPixelSize = areaSnapshot.sizePixelAtStart + pixels\n    // ENLARGE AREA\n    ;\n    // ENLARGE AREA\n    if (pixels > 0) {\n        // If maxSize & newSize bigger than it > absorb to max and return remaining pixels\n        if (areaSnapshot.area.maxSize !== null && tempPixelSize > areaSnapshot.area.maxSize) {\n            return {\n                areaSnapshot,\n                pixelAbsorb: areaSnapshot.area.maxSize - areaSnapshot.sizePixelAtStart,\n                percentAfterAbsorption: -1,\n                pixelRemain: tempPixelSize - areaSnapshot.area.maxSize,\n            };\n        }\n        return {\n            areaSnapshot,\n            pixelAbsorb: pixels,\n            percentAfterAbsorption: -1,\n            pixelRemain: 0,\n        };\n    }\n    // REDUCE AREA\n    else if (pixels < 0) {\n        // If minSize & newSize smaller than it > absorb to min and return remaining pixels\n        if (areaSnapshot.area.minSize !== null && tempPixelSize < areaSnapshot.area.minSize) {\n            return {\n                areaSnapshot,\n                pixelAbsorb: areaSnapshot.area.minSize + pixels - tempPixelSize,\n                percentAfterAbsorption: -1,\n                pixelRemain: tempPixelSize - areaSnapshot.area.minSize,\n            };\n        }\n        // If reduced under zero > return remaining pixels\n        else if (tempPixelSize < 0) {\n            return {\n                areaSnapshot,\n                pixelAbsorb: -areaSnapshot.sizePixelAtStart,\n                percentAfterAbsorption: -1,\n                pixelRemain: pixels + areaSnapshot.sizePixelAtStart,\n            };\n        }\n        return {\n            areaSnapshot,\n            pixelAbsorb: pixels,\n            percentAfterAbsorption: -1,\n            pixelRemain: 0,\n        };\n    }\n}\n/**\n * @param {?} unit\n * @param {?} item\n * @return {?}\n */\nfunction updateAreaSize(unit, item) {\n    if (unit === 'percent') {\n        item.areaSnapshot.area.size = item.percentAfterAbsorption;\n    }\n    else if (unit === 'pixel') {\n        // Update size except for the wildcard size area\n        if (item.areaSnapshot.area.size !== null) {\n            item.areaSnapshot.area.size = item.areaSnapshot.sizePixelAtStart + item.pixelAbsorb;\n        }\n    }\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/component/split.component.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * angular-split\n *\n *\n *  PERCENT MODE ([unit]=\"'percent'\")\n *  ___________________________________________________________________________________________\n * |       A       [g1]       B       [g2]       C       [g3]       D       [g4]       E       |\n * |-------------------------------------------------------------------------------------------|\n * |       20                 30                 20                 15                 15      | <-- [size]=\"x\"\n * |               10px               10px               10px               10px               | <-- [gutterSize]=\"10\"\n * |calc(20% - 8px)    calc(30% - 12px)   calc(20% - 8px)    calc(15% - 6px)    calc(15% - 6px)| <-- CSS flex-basis property (with flex-grow&shrink at 0)\n * |     152px              228px              152px              114px              114px     | <-- el.getBoundingClientRect().width\n * |___________________________________________________________________________________________|\n *                                                                                 800px         <-- el.getBoundingClientRect().width\n *  flex-basis = calc( { area.size }% - { area.size/100 * nbGutter*gutterSize }px );\n *\n *\n *  PIXEL MODE ([unit]=\"'pixel'\")\n *  ___________________________________________________________________________________________\n * |       A       [g1]       B       [g2]       C       [g3]       D       [g4]       E       |\n * |-------------------------------------------------------------------------------------------|\n * |      100                250                 *                 150                100      | <-- [size]=\"y\"\n * |               10px               10px               10px               10px               | <-- [gutterSize]=\"10\"\n * |   0 0 100px          0 0 250px           1 1 auto          0 0 150px          0 0 100px   | <-- CSS flex property (flex-grow/flex-shrink/flex-basis)\n * |     100px              250px              200px              150px              100px     | <-- el.getBoundingClientRect().width\n * |___________________________________________________________________________________________|\n *                                                                                 800px         <-- el.getBoundingClientRect().width\n *\n */\nclass SplitComponent {\n    /**\n     * @param {?} ngZone\n     * @param {?} elRef\n     * @param {?} cdRef\n     * @param {?} renderer\n     */\n    constructor(ngZone, elRef, cdRef, renderer) {\n        this.ngZone = ngZone;\n        this.elRef = elRef;\n        this.cdRef = cdRef;\n        this.renderer = renderer;\n        this._direction = 'horizontal';\n        this._unit = 'percent';\n        this._gutterSize = 11;\n        this._gutterStep = 1;\n        this._restrictMove = false;\n        this._useTransition = false;\n        this._disabled = false;\n        this._dir = 'ltr';\n        this._gutterDblClickDuration = 0;\n        this.dragStart = new EventEmitter(false);\n        this.dragEnd = new EventEmitter(false);\n        this.gutterClick = new EventEmitter(false);\n        this.gutterDblClick = new EventEmitter(false);\n        this.dragProgressSubject = new Subject();\n        this.dragProgress$ = this.dragProgressSubject.asObservable();\n        this.isDragging = false;\n        this.isWaitingClear = false;\n        this.isWaitingInitialMove = false;\n        this.dragListeners = [];\n        this.snapshot = null;\n        this.startPoint = null;\n        this.endPoint = null;\n        this.displayedAreas = [];\n        this.hiddenAreas = [];\n        this._clickTimeout = null;\n        // To force adding default class, could be override by user @Input() or not\n        this.direction = this._direction;\n    }\n    /**\n     * @param {?} v\n     * @return {?}\n     */\n    set direction(v) {\n        this._direction = v === 'vertical' ? 'vertical' : 'horizontal';\n        this.renderer.addClass(this.elRef.nativeElement, `as-${this._direction}`);\n        this.renderer.removeClass(this.elRef.nativeElement, `as-${this._direction === 'vertical' ? 'horizontal' : 'vertical'}`);\n        this.build(false, false);\n    }\n    /**\n     * @return {?}\n     */\n    get direction() {\n        return this._direction;\n    }\n    /**\n     * @param {?} v\n     * @return {?}\n     */\n    set unit(v) {\n        this._unit = v === 'pixel' ? 'pixel' : 'percent';\n        this.renderer.addClass(this.elRef.nativeElement, `as-${this._unit}`);\n        this.renderer.removeClass(this.elRef.nativeElement, `as-${this._unit === 'pixel' ? 'percent' : 'pixel'}`);\n        this.build(false, true);\n    }\n    /**\n     * @return {?}\n     */\n    get unit() {\n        return this._unit;\n    }\n    /**\n     * @param {?} v\n     * @return {?}\n     */\n    set gutterSize(v) {\n        this._gutterSize = getInputPositiveNumber(v, 11);\n        this.build(false, false);\n    }\n    /**\n     * @return {?}\n     */\n    get gutterSize() {\n        return this._gutterSize;\n    }\n    /**\n     * @param {?} v\n     * @return {?}\n     */\n    set gutterStep(v) {\n        this._gutterStep = getInputPositiveNumber(v, 1);\n    }\n    /**\n     * @return {?}\n     */\n    get gutterStep() {\n        return this._gutterStep;\n    }\n    /**\n     * @param {?} v\n     * @return {?}\n     */\n    set restrictMove(v) {\n        this._restrictMove = getInputBoolean(v);\n    }\n    /**\n     * @return {?}\n     */\n    get restrictMove() {\n        return this._restrictMove;\n    }\n    /**\n     * @param {?} v\n     * @return {?}\n     */\n    set useTransition(v) {\n        this._useTransition = getInputBoolean(v);\n        if (this._useTransition) {\n            this.renderer.addClass(this.elRef.nativeElement, 'as-transition');\n        }\n        else {\n            this.renderer.removeClass(this.elRef.nativeElement, 'as-transition');\n        }\n    }\n    /**\n     * @return {?}\n     */\n    get useTransition() {\n        return this._useTransition;\n    }\n    /**\n     * @param {?} v\n     * @return {?}\n     */\n    set disabled(v) {\n        this._disabled = getInputBoolean(v);\n        if (this._disabled) {\n            this.renderer.addClass(this.elRef.nativeElement, 'as-disabled');\n        }\n        else {\n            this.renderer.removeClass(this.elRef.nativeElement, 'as-disabled');\n        }\n    }\n    /**\n     * @return {?}\n     */\n    get disabled() {\n        return this._disabled;\n    }\n    /**\n     * @param {?} v\n     * @return {?}\n     */\n    set dir(v) {\n        this._dir = v === 'rtl' ? 'rtl' : 'ltr';\n        this.renderer.setAttribute(this.elRef.nativeElement, 'dir', this._dir);\n    }\n    /**\n     * @return {?}\n     */\n    get dir() {\n        return this._dir;\n    }\n    /**\n     * @param {?} v\n     * @return {?}\n     */\n    set gutterDblClickDuration(v) {\n        this._gutterDblClickDuration = getInputPositiveNumber(v, 0);\n    }\n    /**\n     * @return {?}\n     */\n    get gutterDblClickDuration() {\n        return this._gutterDblClickDuration;\n    }\n    /**\n     * @return {?}\n     */\n    get transitionEnd() {\n        return new Observable((/**\n         * @param {?} subscriber\n         * @return {?}\n         */\n        (subscriber) => (this.transitionEndSubscriber = subscriber))).pipe(debounceTime(20));\n    }\n    /**\n     * @return {?}\n     */\n    ngAfterViewInit() {\n        this.ngZone.runOutsideAngular((/**\n         * @return {?}\n         */\n        () => {\n            // To avoid transition at first rendering\n            setTimeout((/**\n             * @return {?}\n             */\n            () => this.renderer.addClass(this.elRef.nativeElement, 'as-init')));\n        }));\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n    getNbGutters() {\n        return this.displayedAreas.length === 0 ? 0 : this.displayedAreas.length - 1;\n    }\n    /**\n     * @param {?} component\n     * @return {?}\n     */\n    addArea(component) {\n        /** @type {?} */\n        const newArea = {\n            component,\n            order: 0,\n            size: 0,\n            minSize: null,\n            maxSize: null,\n            sizeBeforeCollapse: null,\n            gutterBeforeCollapse: 0,\n        };\n        if (component.visible === true) {\n            this.displayedAreas.push(newArea);\n            this.build(true, true);\n        }\n        else {\n            this.hiddenAreas.push(newArea);\n        }\n    }\n    /**\n     * @param {?} component\n     * @return {?}\n     */\n    removeArea(component) {\n        if (this.displayedAreas.some((/**\n         * @param {?} a\n         * @return {?}\n         */\n        (a) => a.component === component))) {\n            /** @type {?} */\n            const area = this.displayedAreas.find((/**\n             * @param {?} a\n             * @return {?}\n             */\n            (a) => a.component === component));\n            this.displayedAreas.splice(this.displayedAreas.indexOf(area), 1);\n            this.build(true, true);\n        }\n        else if (this.hiddenAreas.some((/**\n         * @param {?} a\n         * @return {?}\n         */\n        (a) => a.component === component))) {\n            /** @type {?} */\n            const area = this.hiddenAreas.find((/**\n             * @param {?} a\n             * @return {?}\n             */\n            (a) => a.component === component));\n            this.hiddenAreas.splice(this.hiddenAreas.indexOf(area), 1);\n        }\n    }\n    /**\n     * @param {?} component\n     * @param {?} resetOrders\n     * @param {?} resetSizes\n     * @return {?}\n     */\n    updateArea(component, resetOrders, resetSizes) {\n        if (component.visible === true) {\n            this.build(resetOrders, resetSizes);\n        }\n    }\n    /**\n     * @param {?} component\n     * @return {?}\n     */\n    showArea(component) {\n        /** @type {?} */\n        const area = this.hiddenAreas.find((/**\n         * @param {?} a\n         * @return {?}\n         */\n        (a) => a.component === component));\n        if (area === undefined) {\n            return;\n        }\n        /** @type {?} */\n        const areas = this.hiddenAreas.splice(this.hiddenAreas.indexOf(area), 1);\n        this.displayedAreas.push(...areas);\n        this.build(true, true);\n    }\n    /**\n     * @param {?} comp\n     * @return {?}\n     */\n    hideArea(comp) {\n        /** @type {?} */\n        const area = this.displayedAreas.find((/**\n         * @param {?} a\n         * @return {?}\n         */\n        (a) => a.component === comp));\n        if (area === undefined) {\n            return;\n        }\n        /** @type {?} */\n        const areas = this.displayedAreas.splice(this.displayedAreas.indexOf(area), 1);\n        areas.forEach((/**\n         * @param {?} item\n         * @return {?}\n         */\n        (item) => {\n            item.order = 0;\n            item.size = 0;\n        }));\n        this.hiddenAreas.push(...areas);\n        this.build(true, true);\n    }\n    /**\n     * @return {?}\n     */\n    getVisibleAreaSizes() {\n        return this.displayedAreas.map((/**\n         * @param {?} a\n         * @return {?}\n         */\n        (a) => (a.size === null ? '*' : a.size)));\n    }\n    /**\n     * @param {?} sizes\n     * @return {?}\n     */\n    setVisibleAreaSizes(sizes) {\n        if (sizes.length !== this.displayedAreas.length) {\n            return false;\n        }\n        /** @type {?} */\n        const formattedSizes = sizes.map((/**\n         * @param {?} s\n         * @return {?}\n         */\n        (s) => getInputPositiveNumber(s, null)));\n        /** @type {?} */\n        const isValid = isUserSizesValid(this.unit, formattedSizes);\n        if (isValid === false) {\n            return false;\n        }\n        // @ts-ignore\n        this.displayedAreas.forEach((/**\n         * @param {?} area\n         * @param {?} i\n         * @return {?}\n         */\n        (area, i) => (area.component._size = formattedSizes[i])));\n        this.build(false, true);\n        return true;\n    }\n    /**\n     * @private\n     * @param {?} resetOrders\n     * @param {?} resetSizes\n     * @return {?}\n     */\n    build(resetOrders, resetSizes) {\n        this.stopDragging();\n        // ¤ AREAS ORDER\n        if (resetOrders === true) {\n            // If user provided 'order' for each area, use it to sort them.\n            if (this.displayedAreas.every((/**\n             * @param {?} a\n             * @return {?}\n             */\n            (a) => a.component.order !== null))) {\n                this.displayedAreas.sort((/**\n                 * @param {?} a\n                 * @param {?} b\n                 * @return {?}\n                 */\n                (a, b) => (/** @type {?} */ (a.component.order)) - (/** @type {?} */ (b.component.order))));\n            }\n            // Then set real order with multiples of 2, numbers between will be used by gutters.\n            this.displayedAreas.forEach((/**\n             * @param {?} area\n             * @param {?} i\n             * @return {?}\n             */\n            (area, i) => {\n                area.order = i * 2;\n                area.component.setStyleOrder(area.order);\n            }));\n        }\n        // ¤ AREAS SIZE\n        if (resetSizes === true) {\n            /** @type {?} */\n            const useUserSizes = isUserSizesValid(this.unit, this.displayedAreas.map((/**\n             * @param {?} a\n             * @return {?}\n             */\n            (a) => a.component.size)));\n            switch (this.unit) {\n                case 'percent': {\n                    /** @type {?} */\n                    const defaultSize = 100 / this.displayedAreas.length;\n                    this.displayedAreas.forEach((/**\n                     * @param {?} area\n                     * @return {?}\n                     */\n                    (area) => {\n                        area.size = useUserSizes ? (/** @type {?} */ (area.component.size)) : defaultSize;\n                        area.minSize = getAreaMinSize(area);\n                        area.maxSize = getAreaMaxSize(area);\n                    }));\n                    break;\n                }\n                case 'pixel': {\n                    if (useUserSizes) {\n                        this.displayedAreas.forEach((/**\n                         * @param {?} area\n                         * @return {?}\n                         */\n                        (area) => {\n                            area.size = area.component.size;\n                            area.minSize = getAreaMinSize(area);\n                            area.maxSize = getAreaMaxSize(area);\n                        }));\n                    }\n                    else {\n                        /** @type {?} */\n                        const wildcardSizeAreas = this.displayedAreas.filter((/**\n                         * @param {?} a\n                         * @return {?}\n                         */\n                        (a) => a.component.size === null))\n                        // No wildcard area > Need to select one arbitrarily > first\n                        ;\n                        // No wildcard area > Need to select one arbitrarily > first\n                        if (wildcardSizeAreas.length === 0 && this.displayedAreas.length > 0) {\n                            this.displayedAreas.forEach((/**\n                             * @param {?} area\n                             * @param {?} i\n                             * @return {?}\n                             */\n                            (area, i) => {\n                                area.size = i === 0 ? null : area.component.size;\n                                area.minSize = i === 0 ? null : getAreaMinSize(area);\n                                area.maxSize = i === 0 ? null : getAreaMaxSize(area);\n                            }));\n                        }\n                        else if (wildcardSizeAreas.length > 1) {\n                            // More than one wildcard area > Need to keep only one arbitrarily > first\n                            /** @type {?} */\n                            let alreadyGotOne = false;\n                            this.displayedAreas.forEach((/**\n                             * @param {?} area\n                             * @return {?}\n                             */\n                            (area) => {\n                                if (area.component.size === null) {\n                                    if (alreadyGotOne === false) {\n                                        area.size = null;\n                                        area.minSize = null;\n                                        area.maxSize = null;\n                                        alreadyGotOne = true;\n                                    }\n                                    else {\n                                        area.size = 100;\n                                        area.minSize = null;\n                                        area.maxSize = null;\n                                    }\n                                }\n                                else {\n                                    area.size = area.component.size;\n                                    area.minSize = getAreaMinSize(area);\n                                    area.maxSize = getAreaMaxSize(area);\n                                }\n                            }));\n                        }\n                    }\n                    break;\n                }\n            }\n        }\n        this.refreshStyleSizes();\n        this.cdRef.markForCheck();\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n    refreshStyleSizes() {\n        ///////////////////////////////////////////\n        // PERCENT MODE\n        if (this.unit === 'percent') {\n            // Only one area > flex-basis 100%\n            if (this.displayedAreas.length === 1) {\n                this.displayedAreas[0].component.setStyleFlex(0, 0, `100%`, false, false);\n            }\n            else {\n                // Multiple areas > use each percent basis\n                /** @type {?} */\n                const sumGutterSize = this.getNbGutters() * this.gutterSize;\n                this.displayedAreas.forEach((/**\n                 * @param {?} area\n                 * @return {?}\n                 */\n                (area) => {\n                    area.component.setStyleFlex(0, 0, `calc( ${area.size}% - ${((/** @type {?} */ (area.size)) / 100) * sumGutterSize}px )`, area.minSize !== null && area.minSize === area.size, area.maxSize !== null && area.maxSize === area.size);\n                }));\n            }\n        }\n        else if (this.unit === 'pixel') {\n            ///////////////////////////////////////////\n            // PIXEL MODE\n            this.displayedAreas.forEach((/**\n             * @param {?} area\n             * @return {?}\n             */\n            (area) => {\n                // Area with wildcard size\n                if (area.size === null) {\n                    if (this.displayedAreas.length === 1) {\n                        area.component.setStyleFlex(1, 1, `100%`, false, false);\n                    }\n                    else {\n                        area.component.setStyleFlex(1, 1, `auto`, false, false);\n                    }\n                }\n                else {\n                    // Area with pixel size\n                    // Only one area > flex-basis 100%\n                    if (this.displayedAreas.length === 1) {\n                        area.component.setStyleFlex(0, 0, `100%`, false, false);\n                    }\n                    else {\n                        // Multiple areas > use each pixel basis\n                        area.component.setStyleFlex(0, 0, `${area.size}px`, area.minSize !== null && area.minSize === area.size, area.maxSize !== null && area.maxSize === area.size);\n                    }\n                }\n            }));\n        }\n    }\n    /**\n     * @param {?} event\n     * @param {?} gutterNum\n     * @return {?}\n     */\n    clickGutter(event, gutterNum) {\n        /** @type {?} */\n        const tempPoint = getPointFromEvent(event)\n        // Be sure mouseup/touchend happened if touch/cursor is not moved.\n        ;\n        // Be sure mouseup/touchend happened if touch/cursor is not moved.\n        if (this.startPoint &&\n            this.startPoint.x === tempPoint.x &&\n            this.startPoint.y === tempPoint.y &&\n            (!this.isDragging || this.isWaitingInitialMove)) {\n            // If timeout in progress and new click > clearTimeout & dblClickEvent\n            if (this._clickTimeout !== null) {\n                window.clearTimeout(this._clickTimeout);\n                this._clickTimeout = null;\n                this.notify('dblclick', gutterNum);\n                this.stopDragging();\n            }\n            else {\n                // Else start timeout to call clickEvent at end\n                this._clickTimeout = window.setTimeout((/**\n                 * @return {?}\n                 */\n                () => {\n                    this._clickTimeout = null;\n                    this.notify('click', gutterNum);\n                    this.stopDragging();\n                }), this.gutterDblClickDuration);\n            }\n        }\n    }\n    /**\n     * @param {?} event\n     * @param {?} gutterOrder\n     * @param {?} gutterNum\n     * @return {?}\n     */\n    startDragging(event, gutterOrder, gutterNum) {\n        event.preventDefault();\n        event.stopPropagation();\n        this.startPoint = getPointFromEvent(event);\n        if (this.startPoint === null || this.disabled === true || this.isWaitingClear === true) {\n            return;\n        }\n        this.snapshot = {\n            gutterNum,\n            lastSteppedOffset: 0,\n            allAreasSizePixel: getElementPixelSize(this.elRef, this.direction) - this.getNbGutters() * this.gutterSize,\n            allInvolvedAreasSizePercent: 100,\n            areasBeforeGutter: [],\n            areasAfterGutter: [],\n        };\n        this.displayedAreas.forEach((/**\n         * @param {?} area\n         * @return {?}\n         */\n        (area) => {\n            /** @type {?} */\n            const areaSnapshot = {\n                area,\n                sizePixelAtStart: getElementPixelSize(area.component.elRef, this.direction),\n                sizePercentAtStart: this.unit === 'percent' ? area.size : -1,\n            };\n            if (area.order < gutterOrder) {\n                if (this.restrictMove === true) {\n                    this.snapshot.areasBeforeGutter = [areaSnapshot];\n                }\n                else {\n                    this.snapshot.areasBeforeGutter.unshift(areaSnapshot);\n                }\n            }\n            else if (area.order > gutterOrder) {\n                if (this.restrictMove === true) {\n                    if (this.snapshot.areasAfterGutter.length === 0) {\n                        this.snapshot.areasAfterGutter = [areaSnapshot];\n                    }\n                }\n                else {\n                    this.snapshot.areasAfterGutter.push(areaSnapshot);\n                }\n            }\n        }));\n        this.snapshot.allInvolvedAreasSizePercent = [\n            ...this.snapshot.areasBeforeGutter,\n            ...this.snapshot.areasAfterGutter,\n        ].reduce((/**\n         * @param {?} t\n         * @param {?} a\n         * @return {?}\n         */\n        (t, a) => t + a.sizePercentAtStart), 0);\n        if (this.snapshot.areasBeforeGutter.length === 0 || this.snapshot.areasAfterGutter.length === 0) {\n            return;\n        }\n        this.dragListeners.push(this.renderer.listen('document', 'mouseup', this.stopDragging.bind(this)));\n        this.dragListeners.push(this.renderer.listen('document', 'touchend', this.stopDragging.bind(this)));\n        this.dragListeners.push(this.renderer.listen('document', 'touchcancel', this.stopDragging.bind(this)));\n        this.ngZone.runOutsideAngular((/**\n         * @return {?}\n         */\n        () => {\n            this.dragListeners.push(this.renderer.listen('document', 'mousemove', this.dragEvent.bind(this)));\n            this.dragListeners.push(this.renderer.listen('document', 'touchmove', this.dragEvent.bind(this)));\n        }));\n        this.displayedAreas.forEach((/**\n         * @param {?} area\n         * @return {?}\n         */\n        (area) => area.component.lockEvents()));\n        this.isDragging = true;\n        this.isWaitingInitialMove = true;\n    }\n    /**\n     * @private\n     * @param {?} event\n     * @return {?}\n     */\n    dragEvent(event) {\n        event.preventDefault();\n        event.stopPropagation();\n        if (this._clickTimeout !== null) {\n            window.clearTimeout(this._clickTimeout);\n            this._clickTimeout = null;\n        }\n        if (this.isDragging === false) {\n            return;\n        }\n        this.endPoint = getPointFromEvent(event);\n        if (this.endPoint === null) {\n            return;\n        }\n        if (this.isWaitingInitialMove) {\n            if (this.startPoint.x !== this.endPoint.x || this.startPoint.y !== this.endPoint.y) {\n                this.ngZone.run((/**\n                 * @return {?}\n                 */\n                () => {\n                    this.isWaitingInitialMove = false;\n                    this.renderer.addClass(this.elRef.nativeElement, 'as-dragging');\n                    this.renderer.addClass(this.gutterEls.toArray()[this.snapshot.gutterNum - 1].nativeElement, 'as-dragged');\n                    this.notify('start', this.snapshot.gutterNum);\n                }));\n            }\n            else {\n                return;\n            }\n        }\n        // Calculate steppedOffset\n        /** @type {?} */\n        let offset = this.direction === 'horizontal' ? this.startPoint.x - this.endPoint.x : this.startPoint.y - this.endPoint.y;\n        if (this.dir === 'rtl') {\n            offset = -offset;\n        }\n        /** @type {?} */\n        const steppedOffset = Math.round(offset / this.gutterStep) * this.gutterStep;\n        if (steppedOffset === this.snapshot.lastSteppedOffset) {\n            return;\n        }\n        this.snapshot.lastSteppedOffset = steppedOffset;\n        // Need to know if each gutter side areas could reacts to steppedOffset\n        /** @type {?} */\n        let areasBefore = getGutterSideAbsorptionCapacity(this.unit, this.snapshot.areasBeforeGutter, -steppedOffset, this.snapshot.allAreasSizePixel);\n        /** @type {?} */\n        let areasAfter = getGutterSideAbsorptionCapacity(this.unit, this.snapshot.areasAfterGutter, steppedOffset, this.snapshot.allAreasSizePixel)\n        // Each gutter side areas can't absorb all offset\n        ;\n        // Each gutter side areas can't absorb all offset\n        if (areasBefore.remain !== 0 && areasAfter.remain !== 0) {\n            if (Math.abs(areasBefore.remain) === Math.abs(areasAfter.remain)) {\n            }\n            else if (Math.abs(areasBefore.remain) > Math.abs(areasAfter.remain)) {\n                areasAfter = getGutterSideAbsorptionCapacity(this.unit, this.snapshot.areasAfterGutter, steppedOffset + areasBefore.remain, this.snapshot.allAreasSizePixel);\n            }\n            else {\n                areasBefore = getGutterSideAbsorptionCapacity(this.unit, this.snapshot.areasBeforeGutter, -(steppedOffset - areasAfter.remain), this.snapshot.allAreasSizePixel);\n            }\n        }\n        else if (areasBefore.remain !== 0) {\n            // Areas before gutter can't absorbs all offset > need to recalculate sizes for areas after gutter.\n            areasAfter = getGutterSideAbsorptionCapacity(this.unit, this.snapshot.areasAfterGutter, steppedOffset + areasBefore.remain, this.snapshot.allAreasSizePixel);\n        }\n        else if (areasAfter.remain !== 0) {\n            // Areas after gutter can't absorbs all offset > need to recalculate sizes for areas before gutter.\n            areasBefore = getGutterSideAbsorptionCapacity(this.unit, this.snapshot.areasBeforeGutter, -(steppedOffset - areasAfter.remain), this.snapshot.allAreasSizePixel);\n        }\n        if (this.unit === 'percent') {\n            // Hack because of browser messing up with sizes using calc(X% - Ypx) -> el.getBoundingClientRect()\n            // If not there, playing with gutters makes total going down to 99.99875% then 99.99286%, 99.98986%,..\n            /** @type {?} */\n            const all = [...areasBefore.list, ...areasAfter.list];\n            /** @type {?} */\n            const areaToReset = all.find((/**\n             * @param {?} a\n             * @return {?}\n             */\n            (a) => a.percentAfterAbsorption !== 0 &&\n                a.percentAfterAbsorption !== a.areaSnapshot.area.minSize &&\n                a.percentAfterAbsorption !== a.areaSnapshot.area.maxSize));\n            if (areaToReset) {\n                areaToReset.percentAfterAbsorption =\n                    this.snapshot.allInvolvedAreasSizePercent -\n                        all.filter((/**\n                         * @param {?} a\n                         * @return {?}\n                         */\n                        (a) => a !== areaToReset)).reduce((/**\n                         * @param {?} total\n                         * @param {?} a\n                         * @return {?}\n                         */\n                        (total, a) => total + a.percentAfterAbsorption), 0);\n            }\n        }\n        // Now we know areas could absorb steppedOffset, time to really update sizes\n        areasBefore.list.forEach((/**\n         * @param {?} item\n         * @return {?}\n         */\n        (item) => updateAreaSize(this.unit, item)));\n        areasAfter.list.forEach((/**\n         * @param {?} item\n         * @return {?}\n         */\n        (item) => updateAreaSize(this.unit, item)));\n        this.refreshStyleSizes();\n        this.notify('progress', this.snapshot.gutterNum);\n    }\n    /**\n     * @private\n     * @param {?=} event\n     * @return {?}\n     */\n    stopDragging(event) {\n        if (event) {\n            event.preventDefault();\n            event.stopPropagation();\n        }\n        if (this.isDragging === false) {\n            return;\n        }\n        this.displayedAreas.forEach((/**\n         * @param {?} area\n         * @return {?}\n         */\n        (area) => area.component.unlockEvents()));\n        while (this.dragListeners.length > 0) {\n            /** @type {?} */\n            const fct = this.dragListeners.pop();\n            if (fct) {\n                fct();\n            }\n        }\n        // Warning: Have to be before \"notify('end')\"\n        // because \"notify('end')\"\" can be linked to \"[size]='x'\" > \"build()\" > \"stopDragging()\"\n        this.isDragging = false;\n        // If moved from starting point, notify end\n        if (this.isWaitingInitialMove === false) {\n            this.notify('end', this.snapshot.gutterNum);\n        }\n        this.renderer.removeClass(this.elRef.nativeElement, 'as-dragging');\n        this.renderer.removeClass(this.gutterEls.toArray()[this.snapshot.gutterNum - 1].nativeElement, 'as-dragged');\n        this.snapshot = null;\n        this.isWaitingClear = true;\n        // Needed to let (click)=\"clickGutter(...)\" event run and verify if mouse moved or not\n        this.ngZone.runOutsideAngular((/**\n         * @return {?}\n         */\n        () => {\n            setTimeout((/**\n             * @return {?}\n             */\n            () => {\n                this.startPoint = null;\n                this.endPoint = null;\n                this.isWaitingClear = false;\n            }));\n        }));\n    }\n    /**\n     * @param {?} type\n     * @param {?} gutterNum\n     * @return {?}\n     */\n    notify(type, gutterNum) {\n        /** @type {?} */\n        const sizes = this.getVisibleAreaSizes();\n        if (type === 'start') {\n            this.dragStart.emit({ gutterNum, sizes });\n        }\n        else if (type === 'end') {\n            this.dragEnd.emit({ gutterNum, sizes });\n        }\n        else if (type === 'click') {\n            this.gutterClick.emit({ gutterNum, sizes });\n        }\n        else if (type === 'dblclick') {\n            this.gutterDblClick.emit({ gutterNum, sizes });\n        }\n        else if (type === 'transitionEnd') {\n            if (this.transitionEndSubscriber) {\n                this.ngZone.run((/**\n                 * @return {?}\n                 */\n                () => this.transitionEndSubscriber.next(sizes)));\n            }\n        }\n        else if (type === 'progress') {\n            // Stay outside zone to allow users do what they want about change detection mechanism.\n            this.dragProgressSubject.next({ gutterNum, sizes });\n        }\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        this.stopDragging();\n    }\n    /**\n     * @param {?} comp\n     * @param {?} newSize\n     * @param {?} gutter\n     * @return {?}\n     */\n    collapseArea(comp, newSize, gutter) {\n        /** @type {?} */\n        const area = this.displayedAreas.find((/**\n         * @param {?} a\n         * @return {?}\n         */\n        (a) => a.component === comp));\n        if (area === undefined) {\n            return;\n        }\n        /** @type {?} */\n        const whichGutter = gutter === 'right' ? 1 : -1;\n        if (!area.sizeBeforeCollapse) {\n            area.sizeBeforeCollapse = area.size;\n            area.gutterBeforeCollapse = whichGutter;\n        }\n        area.size = newSize;\n        /** @type {?} */\n        const gtr = this.gutterEls.find((/**\n         * @param {?} f\n         * @return {?}\n         */\n        (f) => f.nativeElement.style.order === `${area.order + whichGutter}`));\n        if (gtr) {\n            this.renderer.addClass(gtr.nativeElement, 'as-split-gutter-collapsed');\n        }\n        this.updateArea(comp, false, false);\n    }\n    /**\n     * @param {?} comp\n     * @return {?}\n     */\n    expandArea(comp) {\n        /** @type {?} */\n        const area = this.displayedAreas.find((/**\n         * @param {?} a\n         * @return {?}\n         */\n        (a) => a.component === comp));\n        if (area === undefined) {\n            return;\n        }\n        if (!area.sizeBeforeCollapse) {\n            return;\n        }\n        area.size = area.sizeBeforeCollapse;\n        area.sizeBeforeCollapse = null;\n        /** @type {?} */\n        const gtr = this.gutterEls.find((/**\n         * @param {?} f\n         * @return {?}\n         */\n        (f) => f.nativeElement.style.order === `${area.order + area.gutterBeforeCollapse}`));\n        if (gtr) {\n            this.renderer.removeClass(gtr.nativeElement, 'as-split-gutter-collapsed');\n        }\n        this.updateArea(comp, false, false);\n    }\n}\nSplitComponent.ɵfac = function SplitComponent_Factory(t) { return new (t || SplitComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };\nSplitComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: SplitComponent, selectors: [[\"as-split\"]], viewQuery: function SplitComponent_Query(rf, ctx) { if (rf & 1) {\n        ɵngcc0.ɵɵviewQuery(_c0, 5);\n    } if (rf & 2) {\n        let _t;\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.gutterEls = _t);\n    } }, inputs: { direction: \"direction\", unit: \"unit\", gutterSize: \"gutterSize\", gutterStep: \"gutterStep\", restrictMove: \"restrictMove\", useTransition: \"useTransition\", disabled: \"disabled\", dir: \"dir\", gutterDblClickDuration: \"gutterDblClickDuration\" }, outputs: { dragStart: \"dragStart\", dragEnd: \"dragEnd\", gutterClick: \"gutterClick\", gutterDblClick: \"gutterDblClick\", transitionEnd: \"transitionEnd\" }, exportAs: [\"asSplit\"], ngContentSelectors: _c1, decls: 2, vars: 1, consts: [[\"ngFor\", \"\", 3, \"ngForOf\"], [\"class\", \"as-split-gutter\", 3, \"flex-basis\", \"order\", \"mousedown\", \"touchstart\", \"mouseup\", \"touchend\", 4, \"ngIf\"], [1, \"as-split-gutter\", 3, \"mousedown\", \"touchstart\", \"mouseup\", \"touchend\"], [\"gutterEls\", \"\"], [1, \"as-split-gutter-icon\"]], template: function SplitComponent_Template(rf, ctx) { if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n        ɵngcc0.ɵɵtemplate(1, SplitComponent_ng_template_1_Template, 1, 1, \"ng-template\", 0);\n    } if (rf & 2) {\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngForOf\", ctx.displayedAreas);\n    } }, directives: [ɵngcc1.NgForOf, ɵngcc1.NgIf], styles: [\"[_nghost-%COMP%]{align-items:stretch;display:flex;flex-wrap:nowrap;height:100%;justify-content:flex-start;overflow:hidden;width:100%}[_nghost-%COMP%] > .as-split-gutter[_ngcontent-%COMP%]{align-items:center;background-color:#eee;display:flex;flex-grow:0;flex-shrink:0;justify-content:center}[_nghost-%COMP%] > .as-split-gutter.as-split-gutter-collapsed[_ngcontent-%COMP%]{flex-basis:1px!important;pointer-events:none}[_nghost-%COMP%] > .as-split-gutter[_ngcontent-%COMP%] > .as-split-gutter-icon[_ngcontent-%COMP%]{background-position:50%;background-repeat:no-repeat;height:100%;width:100%}[_nghost-%COMP%]    >.as-split-area{flex-grow:0;flex-shrink:0;overflow-x:hidden;overflow-y:auto}[_nghost-%COMP%]    >.as-split-area.as-hidden{flex:0 1 0px!important;overflow-x:hidden;overflow-y:hidden}.as-horizontal[_nghost-%COMP%]{flex-direction:row}.as-horizontal[_nghost-%COMP%] > .as-split-gutter[_ngcontent-%COMP%]{cursor:col-resize;flex-direction:row;height:100%}.as-horizontal[_nghost-%COMP%] > .as-split-gutter[_ngcontent-%COMP%] > .as-split-gutter-icon[_ngcontent-%COMP%]{background-image:url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAeCAYAAADkftS9AAAAIklEQVQoU2M4c+bMfxAGAgYYmwGrIIiDjrELjpo5aiZeMwF+yNnOs5KSvgAAAABJRU5ErkJggg==\\\")}.as-horizontal[_nghost-%COMP%]    >.as-split-area{height:100%}.as-vertical[_nghost-%COMP%]{flex-direction:column}.as-vertical[_nghost-%COMP%] > .as-split-gutter[_ngcontent-%COMP%]{cursor:row-resize;flex-direction:column;width:100%}.as-vertical[_nghost-%COMP%] > .as-split-gutter[_ngcontent-%COMP%]   .as-split-gutter-icon[_ngcontent-%COMP%]{background-image:url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAFCAMAAABl/6zIAAAABlBMVEUAAADMzMzIT8AyAAAAAXRSTlMAQObYZgAAABRJREFUeAFjYGRkwIMJSeMHlBkOABP7AEGzSuPKAAAAAElFTkSuQmCC\\\")}.as-vertical[_nghost-%COMP%]    >.as-split-area{width:100%}.as-vertical[_nghost-%COMP%]    >.as-split-area.as-hidden{max-width:0}.as-disabled[_nghost-%COMP%] > .as-split-gutter[_ngcontent-%COMP%]{cursor:default}.as-disabled[_nghost-%COMP%] > .as-split-gutter[_ngcontent-%COMP%]   .as-split-gutter-icon[_ngcontent-%COMP%]{background-image:url()}.as-transition.as-init[_nghost-%COMP%]:not(.as-dragging)    >.as-split-area, .as-transition.as-init[_nghost-%COMP%]:not(.as-dragging) > .as-split-gutter[_ngcontent-%COMP%]{transition:flex-basis .3s}\"], changeDetection: 0 });\n/** @nocollapse */\nSplitComponent.ctorParameters = () => [\n    { type: NgZone },\n    { type: ElementRef },\n    { type: ChangeDetectorRef },\n    { type: Renderer2 }\n];\nSplitComponent.propDecorators = {\n    direction: [{ type: Input }],\n    unit: [{ type: Input }],\n    gutterSize: [{ type: Input }],\n    gutterStep: [{ type: Input }],\n    restrictMove: [{ type: Input }],\n    useTransition: [{ type: Input }],\n    disabled: [{ type: Input }],\n    dir: [{ type: Input }],\n    gutterDblClickDuration: [{ type: Input }],\n    transitionEnd: [{ type: Output }],\n    dragStart: [{ type: Output }],\n    dragEnd: [{ type: Output }],\n    gutterClick: [{ type: Output }],\n    gutterDblClick: [{ type: Output }],\n    gutterEls: [{ type: ViewChildren, args: ['gutterEls',] }]\n};\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SplitComponent, [{\n        type: Component,\n        args: [{\n                selector: 'as-split',\n                exportAs: 'asSplit',\n                changeDetection: ChangeDetectionStrategy.OnPush,\n                template: ` <ng-content></ng-content>\n    <ng-template ngFor [ngForOf]=\"displayedAreas\" let-index=\"index\" let-last=\"last\">\n      <div\n        *ngIf=\"last === false\"\n        #gutterEls\n        class=\"as-split-gutter\"\n        [style.flex-basis.px]=\"gutterSize\"\n        [style.order]=\"index * 2 + 1\"\n        (mousedown)=\"startDragging($event, index * 2 + 1, index + 1)\"\n        (touchstart)=\"startDragging($event, index * 2 + 1, index + 1)\"\n        (mouseup)=\"clickGutter($event, index + 1)\"\n        (touchend)=\"clickGutter($event, index + 1)\"\n      >\n        <div class=\"as-split-gutter-icon\"></div>\n      </div>\n    </ng-template>`,\n                encapsulation: ViewEncapsulation.Emulated,\n                styles: [\":host{align-items:stretch;display:flex;flex-wrap:nowrap;height:100%;justify-content:flex-start;overflow:hidden;width:100%}:host>.as-split-gutter{align-items:center;background-color:#eee;display:flex;flex-grow:0;flex-shrink:0;justify-content:center}:host>.as-split-gutter.as-split-gutter-collapsed{flex-basis:1px!important;pointer-events:none}:host>.as-split-gutter>.as-split-gutter-icon{background-position:50%;background-repeat:no-repeat;height:100%;width:100%}:host ::ng-deep>.as-split-area{flex-grow:0;flex-shrink:0;overflow-x:hidden;overflow-y:auto}:host ::ng-deep>.as-split-area.as-hidden{flex:0 1 0px!important;overflow-x:hidden;overflow-y:hidden}:host.as-horizontal{flex-direction:row}:host.as-horizontal>.as-split-gutter{cursor:col-resize;flex-direction:row;height:100%}:host.as-horizontal>.as-split-gutter>.as-split-gutter-icon{background-image:url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAeCAYAAADkftS9AAAAIklEQVQoU2M4c+bMfxAGAgYYmwGrIIiDjrELjpo5aiZeMwF+yNnOs5KSvgAAAABJRU5ErkJggg==\\\")}:host.as-horizontal ::ng-deep>.as-split-area{height:100%}:host.as-vertical{flex-direction:column}:host.as-vertical>.as-split-gutter{cursor:row-resize;flex-direction:column;width:100%}:host.as-vertical>.as-split-gutter .as-split-gutter-icon{background-image:url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAFCAMAAABl/6zIAAAABlBMVEUAAADMzMzIT8AyAAAAAXRSTlMAQObYZgAAABRJREFUeAFjYGRkwIMJSeMHlBkOABP7AEGzSuPKAAAAAElFTkSuQmCC\\\")}:host.as-vertical ::ng-deep>.as-split-area{width:100%}:host.as-vertical ::ng-deep>.as-split-area.as-hidden{max-width:0}:host.as-disabled>.as-split-gutter{cursor:default}:host.as-disabled>.as-split-gutter .as-split-gutter-icon{background-image:url()}:host.as-transition.as-init:not(.as-dragging) ::ng-deep>.as-split-area,:host.as-transition.as-init:not(.as-dragging)>.as-split-gutter{transition:flex-basis .3s}\"]\n            }]\n    }], function () { return [{ type: ɵngcc0.NgZone }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.Renderer2 }]; }, { dragStart: [{\n            type: Output\n        }], dragEnd: [{\n            type: Output\n        }], gutterClick: [{\n            type: Output\n        }], gutterDblClick: [{\n            type: Output\n        }], direction: [{\n            type: Input\n        }], unit: [{\n            type: Input\n        }], gutterSize: [{\n            type: Input\n        }], gutterStep: [{\n            type: Input\n        }], restrictMove: [{\n            type: Input\n        }], useTransition: [{\n            type: Input\n        }], disabled: [{\n            type: Input\n        }], dir: [{\n            type: Input\n        }], gutterDblClickDuration: [{\n            type: Input\n        }], transitionEnd: [{\n            type: Output\n        }], gutterEls: [{\n            type: ViewChildren,\n            args: ['gutterEls']\n        }] }); })();\nif (false) {\n    /**\n     * @type {?}\n     * @private\n     */\n    SplitComponent.prototype._direction;\n    /**\n     * @type {?}\n     * @private\n     */\n    SplitComponent.prototype._unit;\n    /**\n     * @type {?}\n     * @private\n     */\n    SplitComponent.prototype._gutterSize;\n    /**\n     * @type {?}\n     * @private\n     */\n    SplitComponent.prototype._gutterStep;\n    /**\n     * @type {?}\n     * @private\n     */\n    SplitComponent.prototype._restrictMove;\n    /**\n     * @type {?}\n     * @private\n     */\n    SplitComponent.prototype._useTransition;\n    /**\n     * @type {?}\n     * @private\n     */\n    SplitComponent.prototype._disabled;\n    /**\n     * @type {?}\n     * @private\n     */\n    SplitComponent.prototype._dir;\n    /**\n     * @type {?}\n     * @private\n     */\n    SplitComponent.prototype._gutterDblClickDuration;\n    /** @type {?} */\n    SplitComponent.prototype.dragStart;\n    /** @type {?} */\n    SplitComponent.prototype.dragEnd;\n    /** @type {?} */\n    SplitComponent.prototype.gutterClick;\n    /** @type {?} */\n    SplitComponent.prototype.gutterDblClick;\n    /**\n     * @type {?}\n     * @private\n     */\n    SplitComponent.prototype.transitionEndSubscriber;\n    /**\n     * @type {?}\n     * @private\n     */\n    SplitComponent.prototype.dragProgressSubject;\n    /** @type {?} */\n    SplitComponent.prototype.dragProgress$;\n    /**\n     * @type {?}\n     * @private\n     */\n    SplitComponent.prototype.isDragging;\n    /**\n     * @type {?}\n     * @private\n     */\n    SplitComponent.prototype.isWaitingClear;\n    /**\n     * @type {?}\n     * @private\n     */\n    SplitComponent.prototype.isWaitingInitialMove;\n    /**\n     * @type {?}\n     * @private\n     */\n    SplitComponent.prototype.dragListeners;\n    /**\n     * @type {?}\n     * @private\n     */\n    SplitComponent.prototype.snapshot;\n    /**\n     * @type {?}\n     * @private\n     */\n    SplitComponent.prototype.startPoint;\n    /**\n     * @type {?}\n     * @private\n     */\n    SplitComponent.prototype.endPoint;\n    /** @type {?} */\n    SplitComponent.prototype.displayedAreas;\n    /**\n     * @type {?}\n     * @private\n     */\n    SplitComponent.prototype.hiddenAreas;\n    /**\n     * @type {?}\n     * @private\n     */\n    SplitComponent.prototype.gutterEls;\n    /** @type {?} */\n    SplitComponent.prototype._clickTimeout;\n    /**\n     * @type {?}\n     * @private\n     */\n    SplitComponent.prototype.ngZone;\n    /**\n     * @type {?}\n     * @private\n     */\n    SplitComponent.prototype.elRef;\n    /**\n     * @type {?}\n     * @private\n     */\n    SplitComponent.prototype.cdRef;\n    /**\n     * @type {?}\n     * @private\n     */\n    SplitComponent.prototype.renderer;\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/directive/split-area.directive.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nclass SplitAreaDirective {\n    /**\n     * @param {?} ngZone\n     * @param {?} elRef\n     * @param {?} renderer\n     * @param {?} split\n     */\n    constructor(ngZone, elRef, renderer, split) {\n        this.ngZone = ngZone;\n        this.elRef = elRef;\n        this.renderer = renderer;\n        this.split = split;\n        this._order = null;\n        this._size = null;\n        this._minSize = null;\n        this._maxSize = null;\n        this._lockSize = false;\n        this._visible = true;\n        this.lockListeners = [];\n        this.renderer.addClass(this.elRef.nativeElement, 'as-split-area');\n    }\n    /**\n     * @param {?} v\n     * @return {?}\n     */\n    set order(v) {\n        this._order = getInputPositiveNumber(v, null);\n        this.split.updateArea(this, true, false);\n    }\n    /**\n     * @return {?}\n     */\n    get order() {\n        return this._order;\n    }\n    /**\n     * @param {?} v\n     * @return {?}\n     */\n    set size(v) {\n        this._size = getInputPositiveNumber(v, null);\n        this.split.updateArea(this, false, true);\n    }\n    /**\n     * @return {?}\n     */\n    get size() {\n        return this._size;\n    }\n    /**\n     * @param {?} v\n     * @return {?}\n     */\n    set minSize(v) {\n        this._minSize = getInputPositiveNumber(v, null);\n        this.split.updateArea(this, false, true);\n    }\n    /**\n     * @return {?}\n     */\n    get minSize() {\n        return this._minSize;\n    }\n    /**\n     * @param {?} v\n     * @return {?}\n     */\n    set maxSize(v) {\n        this._maxSize = getInputPositiveNumber(v, null);\n        this.split.updateArea(this, false, true);\n    }\n    /**\n     * @return {?}\n     */\n    get maxSize() {\n        return this._maxSize;\n    }\n    /**\n     * @param {?} v\n     * @return {?}\n     */\n    set lockSize(v) {\n        this._lockSize = getInputBoolean(v);\n        this.split.updateArea(this, false, true);\n    }\n    /**\n     * @return {?}\n     */\n    get lockSize() {\n        return this._lockSize;\n    }\n    /**\n     * @param {?} v\n     * @return {?}\n     */\n    set visible(v) {\n        this._visible = getInputBoolean(v);\n        if (this._visible) {\n            this.split.showArea(this);\n            this.renderer.removeClass(this.elRef.nativeElement, 'as-hidden');\n        }\n        else {\n            this.split.hideArea(this);\n            this.renderer.addClass(this.elRef.nativeElement, 'as-hidden');\n        }\n    }\n    /**\n     * @return {?}\n     */\n    get visible() {\n        return this._visible;\n    }\n    /**\n     * @return {?}\n     */\n    ngOnInit() {\n        this.split.addArea(this);\n        this.ngZone.runOutsideAngular((/**\n         * @return {?}\n         */\n        () => {\n            this.transitionListener = this.renderer.listen(this.elRef.nativeElement, 'transitionend', (/**\n             * @param {?} event\n             * @return {?}\n             */\n            (event) => {\n                // Limit only flex-basis transition to trigger the event\n                if (event.propertyName === 'flex-basis') {\n                    this.split.notify('transitionEnd', -1);\n                }\n            }));\n        }));\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    setStyleOrder(value) {\n        this.renderer.setStyle(this.elRef.nativeElement, 'order', value);\n    }\n    /**\n     * @param {?} grow\n     * @param {?} shrink\n     * @param {?} basis\n     * @param {?} isMin\n     * @param {?} isMax\n     * @return {?}\n     */\n    setStyleFlex(grow, shrink, basis, isMin, isMax) {\n        // Need 3 separated properties to work on IE11 (https://github.com/angular/flex-layout/issues/323)\n        this.renderer.setStyle(this.elRef.nativeElement, 'flex-grow', grow);\n        this.renderer.setStyle(this.elRef.nativeElement, 'flex-shrink', shrink);\n        this.renderer.setStyle(this.elRef.nativeElement, 'flex-basis', basis);\n        if (isMin === true) {\n            this.renderer.addClass(this.elRef.nativeElement, 'as-min');\n        }\n        else {\n            this.renderer.removeClass(this.elRef.nativeElement, 'as-min');\n        }\n        if (isMax === true) {\n            this.renderer.addClass(this.elRef.nativeElement, 'as-max');\n        }\n        else {\n            this.renderer.removeClass(this.elRef.nativeElement, 'as-max');\n        }\n    }\n    /**\n     * @return {?}\n     */\n    lockEvents() {\n        this.ngZone.runOutsideAngular((/**\n         * @return {?}\n         */\n        () => {\n            this.lockListeners.push(this.renderer.listen(this.elRef.nativeElement, 'selectstart', (/**\n             * @return {?}\n             */\n            () => false)));\n            this.lockListeners.push(this.renderer.listen(this.elRef.nativeElement, 'dragstart', (/**\n             * @return {?}\n             */\n            () => false)));\n        }));\n    }\n    /**\n     * @return {?}\n     */\n    unlockEvents() {\n        while (this.lockListeners.length > 0) {\n            /** @type {?} */\n            const fct = this.lockListeners.pop();\n            if (fct) {\n                fct();\n            }\n        }\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        this.unlockEvents();\n        if (this.transitionListener) {\n            this.transitionListener();\n        }\n        this.split.removeArea(this);\n    }\n    /**\n     * @param {?=} newSize\n     * @param {?=} gutter\n     * @return {?}\n     */\n    collapse(newSize = 0, gutter = 'right') {\n        this.split.collapseArea(this, newSize, gutter);\n    }\n    /**\n     * @return {?}\n     */\n    expand() {\n        this.split.expandArea(this);\n    }\n}\nSplitAreaDirective.ɵfac = function SplitAreaDirective_Factory(t) { return new (t || SplitAreaDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(SplitComponent)); };\nSplitAreaDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: SplitAreaDirective, selectors: [[\"as-split-area\"], [\"\", \"as-split-area\", \"\"]], inputs: { order: \"order\", size: \"size\", minSize: \"minSize\", maxSize: \"maxSize\", lockSize: \"lockSize\", visible: \"visible\" }, exportAs: [\"asSplitArea\"] });\n/** @nocollapse */\nSplitAreaDirective.ctorParameters = () => [\n    { type: NgZone },\n    { type: ElementRef },\n    { type: Renderer2 },\n    { type: SplitComponent }\n];\nSplitAreaDirective.propDecorators = {\n    order: [{ type: Input }],\n    size: [{ type: Input }],\n    minSize: [{ type: Input }],\n    maxSize: [{ type: Input }],\n    lockSize: [{ type: Input }],\n    visible: [{ type: Input }]\n};\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SplitAreaDirective, [{\n        type: Directive,\n        args: [{\n                selector: 'as-split-area, [as-split-area]',\n                exportAs: 'asSplitArea'\n            }]\n    }], function () { return [{ type: ɵngcc0.NgZone }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: SplitComponent }]; }, { order: [{\n            type: Input\n        }], size: [{\n            type: Input\n        }], minSize: [{\n            type: Input\n        }], maxSize: [{\n            type: Input\n        }], lockSize: [{\n            type: Input\n        }], visible: [{\n            type: Input\n        }] }); })();\nif (false) {\n    /**\n     * @type {?}\n     * @private\n     */\n    SplitAreaDirective.prototype._order;\n    /**\n     * @type {?}\n     * @private\n     */\n    SplitAreaDirective.prototype._size;\n    /**\n     * @type {?}\n     * @private\n     */\n    SplitAreaDirective.prototype._minSize;\n    /**\n     * @type {?}\n     * @private\n     */\n    SplitAreaDirective.prototype._maxSize;\n    /**\n     * @type {?}\n     * @private\n     */\n    SplitAreaDirective.prototype._lockSize;\n    /**\n     * @type {?}\n     * @private\n     */\n    SplitAreaDirective.prototype._visible;\n    /**\n     * @type {?}\n     * @private\n     */\n    SplitAreaDirective.prototype.transitionListener;\n    /**\n     * @type {?}\n     * @private\n     */\n    SplitAreaDirective.prototype.lockListeners;\n    /**\n     * @type {?}\n     * @private\n     */\n    SplitAreaDirective.prototype.ngZone;\n    /** @type {?} */\n    SplitAreaDirective.prototype.elRef;\n    /**\n     * @type {?}\n     * @private\n     */\n    SplitAreaDirective.prototype.renderer;\n    /**\n     * @type {?}\n     * @private\n     */\n    SplitAreaDirective.prototype.split;\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/module.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nclass AngularSplitModule {\n    /**\n     * @return {?}\n     */\n    static forRoot() {\n        console.warn(`AngularSplitModule.forRoot() is deprecated and will be removed in v6`);\n        return {\n            ngModule: AngularSplitModule,\n            providers: [],\n        };\n    }\n    /**\n     * @return {?}\n     */\n    static forChild() {\n        console.warn(`AngularSplitModule.forChild() is deprecated and will be removed in v6`);\n        return {\n            ngModule: AngularSplitModule,\n            providers: [],\n        };\n    }\n}\nAngularSplitModule.ɵfac = function AngularSplitModule_Factory(t) { return new (t || AngularSplitModule)(); };\nAngularSplitModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: AngularSplitModule });\nAngularSplitModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[CommonModule]] });\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(AngularSplitModule, [{\n        type: NgModule,\n        args: [{\n                imports: [CommonModule],\n                declarations: [SplitComponent, SplitAreaDirective],\n                exports: [SplitComponent, SplitAreaDirective]\n            }]\n    }], null, null); })();\n(function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(AngularSplitModule, { declarations: function () { return [SplitComponent, SplitAreaDirective]; }, imports: function () { return [CommonModule]; }, exports: function () { return [SplitComponent, SplitAreaDirective]; } }); })();\n\n/**\n * @fileoverview added by tsickle\n * Generated from: public_api.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * Generated from: angular-split.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\nexport { AngularSplitModule, SplitAreaDirective, SplitComponent };\n\n"],"names":[],"sourceRoot":"webpack:///"}